from selenium import webdriver
from selenium.webdriver import common
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
from selenium.webdriver.firefox.options import Options as FirefoxOptions
from selenium.common.exceptions import NoSuchElementException, StaleElementReferenceException, ElementNotVisibleException
from random import randint, Random
import subprocess
import time
import sys
import os



from faker import Faker
fake = Faker()
# name = fake.name()
name = 'Austin Traver'
# street = fake.street_address()
street = '325 W Adams Blvd Apt 6064'
city = 'Los Angeles'
zipcode = '90007'
password = 'T00slippery'
bookName = sys.argv[1]

# generate fake phone number
# phone = '213'
# for i in range(0,7):
#     phone += str(randint(1,9))
phone = '6507303237'

# generate fake credit card number
visaPrefixList = [
        ['4', '5', '3', '9'],
        ['4', '5', '5', '6'],
        ['4', '9', '1', '6'],
        ['4', '5', '3', '2'],
        ['4', '9', '2', '9'],
        ['4', '0', '2', '4', '0', '0', '7', '1'],
        ['4', '4', '8', '6'],
        ['4', '7', '1', '6'],
        ['4']]
generator = Random()
generator.seed() # seed from current time
creditCard = generator.choice(visaPrefixList)
while len(creditCard) < 15:
    digit = str(generator.choice(range(0, 10)))
    creditCard.append(digit)
sum = 0
pos = 0
reversedcreditCard = []
reversedcreditCard.extend(creditCard)
reversedcreditCard.reverse()
while pos < 15:
    odd = int(reversedcreditCard[pos]) * 2
    if odd > 9:
        odd -= 9
    sum += odd
    if pos != (14):
        sum += int(reversedcreditCard[pos + 1])
    pos += 2
checkdigit = ((int(sum/10) + 1) * 10 - sum)%10
creditCard.append(str(checkdigit))
creditCard = ''.join(creditCard)
creditCard = '4465420596174110'

# print("Generating email...")
# options = FirefoxOptions()
# options.add_argument("--headless")
# fox = webdriver.Firefox(firefox_options=options)
# fox.implicitly_wait(4) # prevents fox from throwing errors too quickly
# fox.get('https://getnada.com/')
# fox.switch_to.window(fox.window_handles[-1])
# time.sleep(0.5)
# email = ''
# import string
# import random
# for i in range(0,6):
#     email += random.choice(string.letters)
email ="atraver@usc.edu"
# print(email)
# save the address of the email generated by slipry


driver = webdriver.Chrome()
driver.implicitly_wait(5) # prevents driver from throwing errors too quickly
driver.get('http:www.audible.com/') # open audible.com

# finds the free trial button
def lookForFreeTrial():
    global driver
    try:
        driver.find_element_by_xpath("//*[@id='anon-mbrshp-button']/a/span").click()
    except (NoSuchElementException, StaleElementReferenceException, ElementNotVisibleException):
        driver.find_element_by_xpath("//img[@class='bc-pub-block ui-it-header-logo']").click()
        time.sleep(1)
        lookForFreeTrial()
lookForFreeTrial()

# pass the next page
driver.switch_to.window(driver.window_handles[-1])
driver.find_element_by_xpath("//*[@id='createAccountSubmit']").click()
driver.switch_to.window(driver.window_handles[-1])
driver.find_element_by_id('ap_customer_name').send_keys(name)
driver.find_element_by_id('ap_email').send_keys(email)
driver.find_element_by_id('ap_password').send_keys(password)
driver.find_element_by_id('ap_password_check').send_keys(password)
driver.find_element_by_xpath("//*[@id='continue']").click()

try: # to bypass the captcha code
    from captcha_solver import CaptchaSolver
    from io import BytesIO
    from PIL import Image
    element = driver.find_element_by_xpath("//img[@id='auth-captcha-image']")
    png = driver.get_screenshot_as_png()
    im = Image.open(BytesIO(png))
    im = im.crop((1000,1190,1380,1330))
    im.save('captcha.png')
    solver = CaptchaSolver('antigate', api_key='18ebda48664c28ce6ebc86baa3701579')
    captcha = open('captcha.png', 'rb').read()
    captchaCode = solver.solve_captcha(captcha) # solves the captcha puzzle
    driver.find_element_by_xpath("//*[@id='auth-captcha-guess']").send_keys(captchaCode)
    driver.find_element_by_id('ap_password').send_keys(password)
    driver.find_element_by_id('ap_password_check').send_keys(password)
    driver.find_element_by_xpath("//*[@id='continue']").click()
except NoSuchElementException: # unless there isn't a captcha code
    pass

# pass the next page
driver.switch_to.window(driver.window_handles[-1])
driver.find_element_by_xpath("//*[@id='payments_widget_add_credit_card_number']").send_keys(creditCard)
driver.find_element_by_xpath("//select[@name='expirationMonth']/option[@value='11']").click()
driver.find_element_by_xpath("//select[@name='expirationYear']/option[@value='2021']").click()
driver.find_element_by_xpath("//*[@id='payments_widget_full_name']").send_keys(name)
driver.find_element_by_xpath("//*[@id='payments_widget_address_line_1']").send_keys(street)
driver.find_element_by_xpath("//*[@id='payments_widget_zip_code']").send_keys(zipcode)
driver.find_element_by_xpath("//*[@id='payments_widget_phone_number']").send_keys(phone)
time.sleep(0.2)
driver.find_element_by_xpath("//*[@id='adbl_ms_confrim_button']").click()
time.sleep(2)
ActionChains(driver).send_keys(Keys.ESCAPE).perform()
try:
    driver.find_element_by_xpath("//*[@id='header-search']").send_keys(bookName) # bug can't send it when "connecting..."
except:
    try:
        driver.find_element_by_xpath("//*[@id='anon-mbrshp-button']/a/span").click()
    except:
        try:
            driver.find_element_by_xpath("//*[@id='zing-image-0']").click()
        except:
            sys.exit()
    driver.find_element_by_xpath("//*[@id='adbl_ms_confrim_button']/button/span").click()
    time.sleep(0.5)
    ActionChains(driver).send_keys(Keys.ESCAPE).perform()
    driver.find_element_by_xpath("//*[@id='header-search']").send_keys(bookName) # bug can't send it when "connecting..."
time.sleep(0.5)
driver.find_element_by_xpath("//*[@id='top-1']/div/div/div/header/div[2]/div[3]/div/div[1]/form/span/i").click()
bookName = driver.find_element_by_xpath("//li[@class='bc-list-item']//h3//a[contains(@class,'bc-color-link') \
                                        and contains(@href,'Audiobook')]").text # updates the book name
time.sleep(0.2)

# pass the next page
driver.find_element_by_xpath("//div[@id='adbl-add-to-cart-0']").click()
WebDriverWait(driver,5).until(expected_conditions.visibility_of_element_located((By.XPATH, "//*[@id='adbl-go-to-cart-button-0']"))).click()
driver.find_element_by_xpath("//*[@id='cart-summary-cta-proceed-to-checkout']/a/span").click()
driver.find_element_by_xpath("//*[@id='cart-summary-cta-complete-purchase']/button/span").click()

time.sleep(1)
step1 = WebDriverWait(driver, 10).until(expected_conditions.visibility_of_element_located((By.XPATH, "//span[contains(text(),'Library') and not(contains(text(),'is'))]")))
ActionChains(driver).move_to_element(step1).perform()
step2 = WebDriverWait(driver, 10).until(expected_conditions.visibility_of_element_located((By.XPATH, "//a[contains(text(),'My Books')]")))
step2.click()

# looks for the book to download
def lookForBook(bookName):
    #bookName must be the EXACT TITLE extracted from audible on a previous page
    global driver
    driver.implicitly_wait(1)
    try:
        foo = "//*[contains(text(),'"+bookName+"')]"
        bar = driver.find_element_by_xpath(foo)
        time.sleep(0.3)
        driver.find_element_by_xpath("//div[@class='bc-col-responsive']//span//a[@class='bc-button-text']").click()
        time.sleep(0.3)
    except NoSuchElementException:
        step1 = WebDriverWait(driver, 10).until(expected_conditions.visibility_of_element_located((By.XPATH, "//span[contains(text(),'Library') and not(contains(text(),'is'))]")))
        ActionChains(driver).move_to_element(step1).perform()
        step2 = WebDriverWait(driver, 10).until(expected_conditions.visibility_of_element_located((By.XPATH, "//a[contains(text(),'My Books')]")))
        step2.click()
        lookForBook(bookName)
lookForBook(bookName)

def fetch_activation_bytes(username, password):
    base_url = 'https://www.audible.com/'
    base_url_license = 'https://www.audible.com/'

    # Step 0
    opts = webdriver.ChromeOptions()
    opts.add_argument("user-agent=Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; AS; rv:11.0) like Gecko")

    # Step 1
    if '@' in username:  # Amazon login using email address
        login_url = "https://www.amazon.com/ap/signin?"
    else:  # Audible member login using username (untested!)
        login_url = "https://www.audible.com/sign-in/ref=ap_to_private?forcePrivateSignIn=true&rdPath=https%3A%2F%2Fwww.audible.com%2F%3F"
    if lang == "uk":
        login_url = login_url.replace('.com', ".co.uk")
        base_url = base_url.replace('.com', ".co.uk")
    elif lang != "us":  # something more clever might be needed
        login_url = login_url.replace('.com', "." + lang)
        base_url = base_url.replace('.com', "." + lang)

    player_id = base64.encodestring(hashlib.sha1("").digest()).rstrip()  # keep this same to avoid hogging activation slots

    payload = {
        'openid.ns': 'http://specs.openid.net/auth/2.0',
        'openid.identity': 'http://specs.openid.net/auth/2.0/identifier_select',
        'openid.claimed_id': 'http://specs.openid.net/auth/2.0/identifier_select',
        'openid.mode': 'logout',
        'openid.assoc_handle': 'amzn_audible_' + lang,
        'openid.return_to': base_url + 'player-auth-token?playerType=software&playerId=%s=&bp_ua=y&playerModel=Desktop&playerManufacturer=Audible' % (player_id)
    }

    else:
        if sys.platform == 'win32':
            chromedriver_path = "chromedriver.exe"
        elif os.path.isfile("/usr/lib/chromium-browser/chromedriver"): # Ubuntu package chromedriver path
            chromedriver_path = "/usr/lib/chromium-browser/chromedriver"
        else:
            chromedriver_path = "./chromedriver"


        driver = webdriver.Chrome(chrome_options=opts,
                                  executable_path=chromedriver_path)

    query_string = urlencode(payload)
    url = login_url + query_string
    driver.get(base_url + '?ipRedirectOverride=true')
    driver.get(url)
    search_box = driver.find_element_by_id('ap_email')
    search_box.send_keys(username)
    search_box = driver.find_element_by_id('ap_password')
    search_box.send_keys(password)
    search_box.submit()
    time.sleep(2)  # give the page some time to load

    # Step 2
    driver.get(base_url + 'player-auth-token?playerType=software&bp_ua=y&playerModel=Desktop&playerId=%s&playerManufacturer=Audible&serial=' % (player_id))
    current_url = driver.current_url
    o = urlparse(current_url)
    data = dict(parse_qsl(o.query))

    # Step 2.5, switch User-Agent to "Audible Download Manager"
    headers = {
        'User-Agent': "Audible Download Manager",
    }
    cookies = driver.get_cookies()
    s = requests.Session()
    for cookie in cookies:
        s.cookies.set(cookie['name'], cookie['value'])

    # Step 3, de-register first, in order to stop hogging all activation slots
    # (there are 8 of them!)
    durl = base_url_license + 'license/licenseForCustomerToken?' \
        + 'customer_token=' + data["playerToken"] + "&action=de-register"
    s.get(durl, headers=headers)

    # Step 4
    url = base_url_license + 'license/licenseForCustomerToken?' \
        + 'customer_token=' + data["playerToken"]
    response = s.get(url, headers=headers)

    with open("activation.blob", "wb") as f:
        f.write(response.content)
    activation_bytes, _ = common.extract_activation_bytes(response.content)
    print("activation_bytes: " + activation_bytes)

    # Step 5 (de-register again to stop filling activation slots)
    s.get(durl, headers=headers)

    # driver.get(url)
    time.sleep(8)
    driver.quit()

fetch_activation_bytes("pasto1947@cuvox.de","H4pp1n3ss")

#
# # extract activation bytes
# base_url = 'https://www.audible.com/'
# base_url_license = 'https://www.audible.com/'
# login_url = 'https://www.amazon.com/ap/signin?'
# import hashlib
# import base64
# from urllib import urlencode
# from urlparse import urlparse, parse_qsl
# player_id = base64.encodestring(hashlib.sha1('').digest()).rstrip()  # keep this same to avoid hogging activation slots
# payload = {
#     'openid.ns': 'http://specs.openid.net/auth/2.0',
#     'openid.identity': 'http://specs.openid.net/auth/2.0/identifier_select',
#     'openid.claimed_id': 'http://specs.openid.net/auth/2.0/identifier_select',
#     'openid.mode': 'logout',
#     'openid.assoc_handle': 'amzn_audible_' + 'us',
#     'openid.return_to': base_url + 'player-auth-token?playerType=software&playerId=%s=&bp_ua=y&playerModel=Desktop&playerManufacturer=Audible' % (player_id)
# }
# query_string = urlencode(payload)
# url = login_url + query_string
# driver.get(base_url + 'player-auth-token?playerType=software&bp_ua=y&playerModel=Desktop&playerId=%s&playerManufacturer=Audible&serial=' % (player_id))
# driver.switch_to.window(driver.window_handles[-1])
# current_url = driver.current_url
# o = urlparse(current_url)
# data = dict(parse_qsl(o.query))
# headers = {
#     'User-Agent': "Audible Download Manager",
# }
# cookies = driver.get_cookies()
# import requests
# s = requests.Session()
# for cookie in cookies:
#     s.cookies.set(cookie['name'], cookie['value'])
# durl = base_url_license + 'license/licenseForCustomerToken?' \
#     + 'customer_token=' + data['playerToken'] + '&action=de-register'
# s.get(durl, headers=headers)
# def extract_activation_bytes(data):
#     global driver
#     if (b"BAD_LOGIN" in data or b"Whoops" in data) or \
#             b"group_id" not in data:
#         print(data)
#         print("\nActivation failed")
#         driver.quit()
#         sys.exit()
#     k = data.rfind(b"group_id")
#     l = data[k:].find(b")")
#     keys = data[k + l + 1 + 1:]
#     output = []
#     output_keys = []
#     import binascii
#     for i in range(0, 8):
#         key = keys[i * 70 + i:(i + 1) * 70 + i]
#         h = binascii.hexlify(bytes(key))
#         h = [h[i:i+2] for i in range(0, len(h), 2)]
#         h = b",".join(h)
#         output_keys.append(h)
#         output.append(h.decode('utf-8'))
#     activation_bytes = output_keys[0].replace(b",", b"")[0:8]
#     activation_bytes = "".join(reversed([activation_bytes[i:i+2] for i in
#                                      range(0, len(activation_bytes), 2)]))
#     return activation_bytes
# url = base_url_license + 'license/licenseForCustomerToken?' \
#     + 'customer_token=' + data["playerToken"]
# response = s.get(url, headers=headers)
# with open("activation.blob", "wb") as f:
#     f.write(response.content)
# activation_bytes = extract_activation_bytes(response.content)
# print(activation_bytes)
# s.get(durl, headers=headers)
#
#
# files = [os.path.join('/Users/austintraver/Downloads', x) for x in os.listdir('/Users/austintraver/Downloads') if x.endswith(".crdownload")]
# aaxFile = max(files , key = os.path.getctime)[:-11]
# while filter(lambda x: os.path.basename(aaxFile)+'.crdownload' in x,os.listdir('/Users/austintraver/Downloads')):
#     time.sleep(1) # wait for the download to finish
# driver.quit() # terminate the driver after the download finishes
#
# oFile = ''
# for k in bookName.split():
#     k = k.replace(k[0],k[0].upper(),1)
#     oFile+=k
# oFile = oFile.replace(oFile[0],oFile[0].lower(),1)
# oFile = oFile.replace('\'','')
# oFile = oFile.replace('!','')
# oFile = oFile.replace('?','')
# oFile = oFile.replace('&',"And")
# os.chdir('/Users/austintraver/Documents/ripper')
# subprocess.call(['./decrypt',activation_bytes,aaxFile,oFile],stdout=None,stderr=None)
# subprocess.call(['open','-a','iTunes','/Users/austintraver/Downloads/'+oFile+'.mp3'])
